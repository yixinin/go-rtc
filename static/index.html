<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>视频聊天</title>
    <style>
        video {
            width: 320px;
            height: 240px;
            border: 1px solid black;
        }

        div {
            display: inline-block;
        }
    </style>
</head>

<body>
    <!-- 次空白脚本转为查询参数预留 -->
    <script></script>

    <script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js" type="text/javascript"></script>

    <script src="https://webrtc.github.io/adapter/adapter.js" type="text/javascript"></script>

    <script type="text/javascript" src="/static/js/clientXHRSignaling.js"></script>

    <script>

        var randUid = Math.floor(Math.random() * 10000 + 1);
        var cands = new Array()

        var signalingChannel, key, id,
            haveLocalMedia = false,
            weWaited = false,
            myVideoStream, myVideo,
            yourVideoStream, yourVideo,
            doNothing = function () { },
            pc,
            constraints = {
                mandatory: {
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                }
            }

        // 自动开始获取本地媒体
        window.onload = function () {
            document.getElementById('uid').innerText = "uid:" + randUid
            createPC()

            myVideo = document.getElementById('myVideo')
            yourVideo = document.getElementById('yourVideo')
            getMedia()
        }
        //发送offer
        function send_offer(offer) {
            var fromUid = document.getElementById('fromUid').value

            var req = {
                offer: offer.sdp,
                fromUid: fromUid,
                uid: randUid
            }

            $.post('/getAnswer',
                req,
                function (data, status) {
                    console.log("get answer " + status);
                    if (data) {
                        var answer = {
                            sdp: data,
                            type: "answer"
                        }
                        pc.setRemoteDescription(new RTCSessionDescription(answer))
                    }
                });


        }

        //发送candidate
        function send_candidate() {
            for (let i in cands) {
                var req = {
                    "uid": randUid,
                    "candidate": cands[i]
                }
                console.log(cands[i])
                post('/sendCandidate', req);
            }

        }

        function post(r, opt) {
            $.ajax({
                type: "post",
                url: r,
                dataType: "json",
                //contentType : "application/json",      //网上很多介绍加上此参数的，后来我发现不加入这个参数才会请求成功。
                data: JSON.stringify(opt),
                success: function (d) {
                    console.log(d);
                }
            });
        }
        // 获取本地媒体
        function getMedia() {
            (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia)({
                audio: true,
                video: true
            }, gotUserMedia, didntGetUserMedia)
        }
        function didntGetUserMedia() {
            console.log('cound not get user media')
            pc.addTransceiver('video')
            navigator.mediaDevices.getDisplayMedia({
                video: true
            }).then(stream => {
                myVideoStream = stream
                haveLocalMedia = true
                //we have a stream, attach it to a feedback video element
                myVideo.srcObject = myVideoStream
                attachMediaIfReady()
            }, error => {
                console.log("Unable to acquire screen capture", error);
            });

        }
        function gotUserMedia(stream) {
            myVideoStream = stream
            haveLocalMedia = true
            // 向我显示我的本地视频
            myVideo.srcObject = myVideoStream
            // 等待pc创建完毕
            attachMediaIfReady()
        }

        // 创建对等连接，即实例化peerConnection
        function createPC() {

            config = new Array();
            config.push({
                url: 'stun:stun.ideasip.com'
            })
            config.push({
                url: 'stun:stun.voipgate.com:3478'
            })

            console.log('config: ', JSON.stringify(config))
            pc = new RTCPeerConnection({
                iceServers: config,
                // sdpSemantics: 'plan-b',
                sdpSemantics: 'unified-plan',
            })
            pc.onicecandidate = onIceCandidate
            pc.onaddstream = onRemoteStreamAdded
            pc.onremovestream = onRemoteStreamRemoved

            // 等待媒体就绪
            attachMediaIfReady()
        }

        // 如果当前浏览器有另一个候选项，将其发送给对等端
        function onIceCandidate(e) {
            if (e.candidate) {
                var cand = {
                    "sdpMid": e.candidate.sdpMid,
                    "sdpMlineindex": e.candidate.sdpMLineIndex,
                    "candidate": e.candidate.candidate
                }
                if (cands.length == 0) {
                    setTimeout("send_candidate()", "4000");
                }
                cands.push(cand)


            }
        }

        // 如果我们浏览器检测到另一端加入了媒体流，则将其显示在屏幕上
        function onRemoteStreamAdded(e) {
            yourVideoStream = e.stream
            console.log('yourVideo: ', yourVideo)
            yourVideo.srcObject = yourVideoStream
        }

        // 远端移除流，这里不做操作
        function onRemoteStreamRemoved(e) {

        }

        function attachMediaIfReady() {
            if (pc && haveLocalMedia) attachMedia()
        }

        // 将本地流添加至对等连接
        function attachMedia() {
            pc.addStream(myVideoStream)
            // if (queryParams && queryParams['call'] && !weWaited) {
            // call()
            // }
        }

        // 生成一个offer
        function call() {
            pc.createOffer(gotDescription, doNothing, constraints)
        }

        // 应答会话描述，生成answer
        function answer() {
            pc.createAnswer(gotDescription, doNothing, constraints)
        }

        // 一旦获取到了会话描述，就将其作为本地描述，然后将其发送至另一端的浏览器
        function gotDescription(localDesc) {
            pc.setLocalDescription(localDesc)
            send_offer(localDesc)
        }

    </script>

    <div id="setup">
        <p>WebRTC 视频聊天demo测试</p>

        <p id="uid"></p>
        <p>
            <input id="fromUid">
            <button id="call" onclick="call()">呼叫</button>
        </p>
    </div>

    <div id="scMessage" style="float:right;display:none">
        <p>信道消息：
            <input type="text" width="100%" name="message" id="message"
                onkeyup="if (event.keyCode == 13){send();return false;}" />
            <button id="send" style="display:none" onclick="send()">发送</button>
        </p>

        <p>响应：
            <span id="response"></span>
        </p>
    </div>

    <br />

    <div style="width:30%;vertical-align:top">
        <div>
            <video autoplay="autoplay" id="myVideo" controls muted="true" />
        </div>
        <p>
            <b>发出的消息</b>
            <br />
            <textarea id="outmessages" style="width:100%" rows="30"></textarea>
        </p>
    </div>

    <div style="width:30%;vertical-align:top;margin-left:200px;">
        <div>
            <video id="yourVideo" autoplay="autoplay" controls muted="true" />
        </div>
        <p>
            <b>收到的消息</b>
            <br />
            <textarea id="inmessages" style="width:100%" rows="30"></textarea>
        </p>
    </div>

</body>

</html>